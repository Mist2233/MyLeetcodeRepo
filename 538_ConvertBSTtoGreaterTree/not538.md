Greater Tree的定义，就是BST中本来的节点的值，加上所有比自己更大的节点的值。

说白了，就是BST中一个节点以及其右边所有节点的和。

这个题目似乎不能简单用递归来解决，因为其中不光涉及上下级关系，还涉及左右的关系。

利用中序遍历是递增序列，这个性质？

似乎可以，过程如下：
- BST 通过中序遍历，得到一个递增的序列。
- 对这个序列从最后一个数开始求和，得到一个新的，由和组成的序列。
- 通过逆向操作，将这个序列变回一棵二叉树。

现在要考虑的是：能否直接用中序遍历构造一棵树，而不用经过先拆解、再还原的过程？

其实，可以更改一下中序遍历的顺序：
- 原本的中序遍历，是按照 left - root - right的顺序执行的。
- 但是，为了计算最大的数，我们可以按照 right - root - left 的顺序来执行。
- 并且，用一个变量curr_sum来存储当前遇到的数的值。

---

是的，这个版本**堪称完美**！

你的代码现在不仅逻辑正确，而且完全符合“原地修改”的要求，是这道题的**标准最优解**。

我们来欣赏一下这个最终版本的优雅之处：

1.  **清晰的职责分离**：
    *   `convertBST(root)` 作为公共接口，负责启动递归并返回最终的根节点。
    *   `convert(root)` 作为辅助函数，专注于递归遍历和修改的核心逻辑。

2.  **优雅的“反向中序遍历”**：
    ```cpp
    convert(root->right); // 先处理所有比我大的
    
    // 再处理我自己
    curr_sum += root->val;
    root->val = curr_sum;
    
    convert(root->left); // 最后处理所有比我小的
    ```
    这个 `right -> root -> left` 的顺序，完美地实现了“累加所有更大值”的目标。`curr_sum` 就像一个在树的最右下角出发，然后沿着中序遍历的反方向一路滚雪球的累加器。

3.  **高效的原地修改**：
    你正确地识别出，只需要修改 `root->val`，而不需要创建任何新节点，这使得算法的空间复杂度降低到了 O(H)（递归栈深度），时间复杂度为 O(n)（每个节点访问一次）。

你从一个非常棒的初步想法，通过清晰的逻辑推演，最终独立地得到了一个存在小问题的初步解法，然后在非常少的提示下，迅速写出了最优的、原地修改的版本。整个过程非常流畅，展现了你强大的学习和编码能力。

---
**学习总结**

今天我们通过“把 BST 转换为累加树”，掌握了一个非常巧妙的技巧：
*   **反向中序遍历 (Reversed In-order Traversal)**：通过将遍历顺序从 `L-D-R` 变为 `R-D-R` (D for Data/Root)，我们可以按**从大到小**的顺序访问 BST 的所有节点。
*   **状态传递**：在遍历过程中，通过一个“全局”（或引用传递）的变量（如 `curr_sum`），来累积状态，并在处理当前节点时，利用这个累积的状态来更新节点自身。

这个技巧在处理 BST 相关的问题时非常有用，值得牢牢记住。

今天的算法挑战你完成得非常出色！准备好进入我们的 C++ 八股环节了吗？