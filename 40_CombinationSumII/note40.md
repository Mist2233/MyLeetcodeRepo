https://leetcode.cn/problems/combination-sum-ii/description/

这道题，和39题的唯一区别，似乎就是，要求我们不能用重复的数字。

那么，在39题的基础上稍微修改即可。正好，我可以复习一下昨天39题的写法。

因此，这一道题目，我不看39题的解法，自己重新独立完成一遍。

---

现在的问题：数组中本来就有重复的数字，然后这些重复的数字会造成一些重复的解，我需要排除重复的解。

比如，示例中，我就是因为没有排除重复的解答，而错误。

可以设一个指针，让它总是指向新的数字，而不是重复的数字。但是，这个时候又不能把那些合理的重复数字的解答给排除掉。

那么发现一个重要结论：
> 如果有重复数字的解答，那么在这些同样数字的第一个时就可以囊括所有的解答。

因此，我们要做的修改就是，每一次将start_idx指向下一个不是重复的数字。

---
我只希望一些特定的start_idx，其他的start_idx都是不合法的。

什么start_idx合法？就是每个新的数字开始的那个start_idx

---
等下，这样似乎也不对，因为跳得太多了。

---

## 🎯 **问题的关键突破：**

**核心问题：** 如何既排除重复解，又保留合法的重复数字使用？

### **错误的做法：**
```cpp
if (i != 0 && candidates[i] == candidates[i - 1]) continue;
```
**问题：** 这会跳过**所有**重复数字，包括不同递归层中的合法使用。

### **正确的做法：**
```cpp
if (i > start_idx && candidates[i] == candidates[i - 1]) continue;
```
**关键：** 只在**同一层循环**中跳过重复数字，允许**不同递归层**使用相同数字。

---

## 📝 **两者的微妙区别：**

### **`i != 0` vs `i > start_idx`**

**场景举例：** 数组 `[1, 1, 2]`，目标 `4`

```
使用 i != 0 的情况：
第一层: i=0, candidates[0]=1 ✅ 选择第一个1
├── 第二层: i=1, candidates[1]=1 ❌ 被跳过！(i!=0 且重复)
└── 第二层: i=2, candidates[2]=2 ✅ 不是解，跳过
结果: 漏掉了 [1,1,2] 这个合法解！

使用 i > start_idx 的情况：
第一层: i=0, start_idx=0, candidates[0]=1 ✅ 选择第一个1
├── 第二层: i=1, start_idx=1, candidates[1]=1 ✅ (i==start_idx，不跳过)
│   └── 第三层: i=2, start_idx=2, candidates[2]=2 ✅ 得到解 [1,1,2]
└── 第二层: i=2, start_idx=1, candidates[2]=2 ✅ 没有解，跳过

第一层: i=1, start_idx=0, candidates[1]=1 ❌ (i>start_idx且重复，跳过)
```

---

## 💡 **理解要点：**

1. **同层去重：** `i > start_idx` 确保在同一个for循环中，相同的数字只使用第一个
2. **跨层允许：** 不同递归层（不同的start_idx）可以使用相同的数字
3. **排序前提：** 必须先排序，让相同数字相邻，便于去重判断

**记忆口诀：** 
> 同层不重复，跨层可重复！

这个微妙的区别就是40题的精髓所在！

